---
author: "Ben Artin"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Seasonal infection example}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
  %\VignetteDepends{outbreakinference, reshape, mgcv, data.table, ggplot2, ggstance, knitr}
---
# Disease outbreak outcome estimation using penalized splines

The purpose of this package is to allow estimation of complex outcome measures of infectious disease outbreaks.

The package works by using generalized additive models (GAMs) with penalized basis splines (p-splines) to approximate the observed data. Approximating splines are sampled from their distribution, and for each approximating spline, the outcome measure of interest is calculated. This yields a sampling distribution of the outcome measure of interest, from which point and itnerval estimates can then be obtained. 

We begin by loading the package:

```{r package, include=TRUE}
library(outbreakinference)
```

```{r libraries, include=FALSE}
library(reshape)
library(dplyr)
library(mgcv)
library(data.table)
library(ggplot2)
library(ggstance)
library(knitr)

opts_chunk$set(fig.width=4, fig.height=3, fig.align="center", dev='svg')
```

```{r plot utilities, include=FALSE}
# These are utilities used for plots in the vignette

# Correspondence between epi weeks and month labels. 
# Fudge by .01 to let minor gridlines show through
epiWeekBreaks <- c(3.01, 7.25, 11.75, 16.01, 20.25, 24.75, 29.01, 33.01, 37.5, 42.01, 46.25, 50.75)
epiWeekLabels <- c("Jul", "Aug", "Sep", "Oct", "Nov", "Dec", "Jan", "Feb", "Mar", "Apr", "May", "Jun")

breaks.df <- data.frame(i=seq(1, 12), mid=epiWeekBreaks)
monthBoundaries <- breaks.df %>%
  inner_join(
    breaks.df %>% mutate(i=i %% 12 + 1) %>% rename(prevMid=mid),
    by="i"
  ) %>%
  inner_join(
    breaks.df %>% mutate(i=(i - 2) %% 12 + 1) %>% rename(nextMid=mid),
    by="i"
  ) %>%
  mutate(
    min=(prevMid + (mid - prevMid) %% 52 / 2) %% 52,
    max=mid + (nextMid - mid) %% 52 / 2
  ) %>%
  select(i, min, mid, max)

basePlot <- function(data) {
  ggplot(data) +
    theme_light() +
    scale_y_continuous() +
    scale_x_continuous(breaks=monthBoundaries$mid, labels=epiWeekLabels, expand=c(0, 0)) + 
    labs(x=NULL, y=NULL) + 
    coord_cartesian(xlim=range(c(monthBoundaries$min, monthBoundaries$max))) +
    theme(
      panel.grid.major.x=element_blank(),
      legend.title=element_blank(),
      axis.ticks.x=element_blank(),
      axis.text.x=element_text(hjust=0.5, vjust=0.5),
      legend.position="bottom"
    )
}

```

Next, we load observations. The example dataset is a CSV file consisting of weekly (`time`) count of cases of a seasonal infectious disease (`cases`).

We also calculate observed cumulative incidence (absolute and relative) here; these are used only for subsequent visualization, not for analysis.

```{r data, include=TRUE}
obs <- read.csv("seasonal.csv")
obs$cases.cum <- cumsum(obs$cases)
obs$cases.cum.frac <- obs$cases.cum / max(obs$cases.cum)
```

Next, we generate a log-linked (`family=poisson`) GAM with 20-knot (`k=20`) cubic (`m=3`) cyclic P-splines (`bs="cp"`). You can vary the number of knots as needed. Fewer knots result in faster computation, but looser fit; more knots will take longer to compute, but increasing the number of knots beyond a certain point will not improve the fit. We chose 20 knots for our analysis by increasing the number of knots and plotting the model predictions until fit visualy converged. 

```{r model, include=TRUE}
model <- gam(cases ~ s(time, k=20, bs="cp", m=3), family=poisson, data=obs)
```

Generate a vector of time values at which the model will be sampled. This is used for analysis (whenever the analysis requires numeric integration or differentiation) as well as visualization (whenever a spline is plotted). Higher `sampleFreq` increases the accuracy of results, but also increases computation time.

This runs from one half time period (inclusive) before the start of the observed times to one half time period (non-inclusive) after the end of the observed times. 

```{r model time, include=TRUE}
sampleFreq <- 20
modelTime <- seq(min(obs$time) - 0.5, max(obs$time) + 0.5 - 1 / sampleFreq, 1 / sampleFreq)
```

This is the number of samples that will be drawn from the outcome distribution. Higher `n` decreases variance of results, but also increases computation time.

```{r model samples, include=TRUE}
n <- 2000
```

There are two main types of outcome measures that this package can estimate: time series outcomes (in which an outcome estimate is calculated for each observed time point), and scalar outcomes (in which a single overall outcome estimate is calculated). 

## Example 1: Time series outcome estimation

In this simple example, we estimate the 95% confidence interval for infection case counts. The workhorse of time series estimation is the `outbreak.estimate.timeseries` function, which takes three parameters: a vector of sampling times (`modelTime`, which we set up above), a function which calculates the desired outcome, and the number of samples we want to calculate (`n`).

We will see examples later of how to estimate custom outcomes, but for this simple example we can use the `outbreak.calc.cases` function (which is built into the package) to calculate our outcome of interest. 

```{r estimate cases, include=TRUE}
casesEst <- model %>%
  outbreak.estimate.timeseries(modelTime, outbreak.calc.cases, samples=n, level=0.95)
```

The result of calling `outbreak.estimate.timeseries` includes sampled times (`time`), point estimates of our desired outcome (`median`), as well as an upper and lower confidence level (`upper` and `lower`), which we can plot:

```{r plot cases, include=TRUE}
basePlot(casesEst) +
  geom_ribbon(aes(x=time, ymin=lower, ymax=upper), fill=grey(.75)) +
  geom_point(data=obs, aes(x=time, y=cases)) +
  labs(x=NULL, y="Cases")
```

## Example 2: Time series outcome estimation

Another simple outcome measure that the package can calculate for us is the relative cumulative incidence, using the `outbreak.calc.cumcases` function. Here we estimate and plot cumulative incidence at the 95% confidence level:

```{r estimate cum cases, include=TRUE}
cumCasesEst <- model %>%
  outbreak.estimate.timeseries(modelTime, outbreak.calc.cumcases, samples=n, level=0.95)

basePlot(cumCasesEst) +
  geom_ribbon(aes(x=time, ymin=lower, ymax=upper), fill=grey(.75)) +
  geom_point(data=obs, aes(x=time, y=cases.cum.frac)) +
  labs(x=NULL, y="Relative cumulative incidence")
```

## Example 3: Accessing individual time series samples

The package provides access to the individual samples of the outcome measure, which can be helpful for visualization. For example, if you ask for 15 sampled estimates of case counts, you will get a 15-column matrix, with each column containing a single time series of case counts:

```{r plot cases estimates, include=TRUE}
casesSamples <- model %>%
  outbreak.estimate.timeseries.sample(modelTime, outbreak.calc.cases, samples=15)
  
# Prepare the data for plotting
casesSamples <- casesSamples %>%
  data.frame() %>%
  setnames(as.character(c(1:ncol(casesSamples)))) %>%
  cbind(time=modelTime) %>%
  melt(c("time")) %>%
  rename(sample=variable, cases=value)

basePlot(casesSamples) +
  geom_line(aes(x=time, y=cases, group=sample), color=grey(.75)) +
  geom_point(data=obs, aes(x=time, y=cases)) +
  labs(y="Cases")
```

## Example 4: Combining sampled outcomes with summary statistics

Note that calling `outbreak.estimate.timeseries.sample` produces a new random sample, which in no way corresponds to other previously sampled outcomes. If you need to both access the individual outcome samples and calculate the confidence intervals for those samples, you can use `outbreak.estimate.timeseries.confints`. 

```{r cases estimates and stats, include=TRUE}
casesSamples <- model %>%
  outbreak.estimate.timeseries.sample(modelTime, outbreak.calc.cases, samples=15)
  
casesEst <- casesSamples %>% 
  outbreak.estimate.timeseries.confints(level=0.95)
```

Here `casesSamples` is a 15-column matrix of sampled case count estimates (as in example 3 above), and `casesEst` is a data frame containing the median, the lowel CL, and the upper CL of the case count (as in example 2 above) *for the same 15 samples*.

## Example 5: Estimation of a custom time series outcome

Suppose that the infection we are investigating progresses to serious disease in 80% of cases, but that it can be treated — before it progresses — with a treatment that has a 90% success rate. Also suppose that our supply is limited to 100 treatments, and that treatment is administered to all infected people until we run out of supply.

Then, among the first 100 cases, 10% will fail treatment, of which 80% will progress to serious disease; for all subsequent cases, no treatment will be available, and 80% will progress to serious disease. We are interested in an estimate of the number of cases of serious disease (as a function of time), based on our observations of the number of cases of the underlying infection.

The package does not include a built-in way to calculate this outcome, but we can write a custom function to do it. This function will take a model object (`model`, obtained from the call to `gam()` above), a model parameters matrix (`params`), and a vector of time values to sample (`time`). It will return a vector of sampled outcome estimates.

```{r custom time series calc, include=TRUE}
seriousDiseaseCases <- function(model, params, time) {
  # Get model predictions for given (randomized) param values
  predictors <- model %>% predict(data.frame(time=time), type="lpmatrix")
  fit <- predictors %*% params

  # Map spline fit back to case counts
  cases <- fit %>% model$family$linkinv()
  
  # Calculate cumulative case counts to determine when we run out of treatment. Note that the model is sampled at sampleFreq, and therefore has sampleFreq observations per unit of time; as a result, we have to multiple the cumulative sums by 1 / sampleFreq.
  cumCases <- cumsum(cases) / sampleFreq
  treatmentAvail <- cumCases < 100

  # Calculate serious disease case counts
  cases[treatmentAvail] <- cases[treatmentAvail] * (1 - 0.9)
  cases <- cases * 0.8
  return(cases)
}
```

We can now combine our custom outcome measure calculation with time series estimation:

```{r custom time series est, include=TRUE}
seriousEst <- model %>%
  outbreak.estimate.timeseries(modelTime, seriousDiseaseCases, samples=n, level=0.95)
```

Our custom outcome calculation function will probably be more useful if we allow progression rate, treatment success rate, and treatment supply to be varied. We can accomplish this by using a function within a function:

```{r custom calc parameterized, include=TRUE}
seriousDiseaseCases <- function(progressionRate, treatmentSuccessRate, treatmentMax, sampleFreq) {
  function(model, params, time) {
    # Get model predictions for given (randomized) param values
    predictors <- model %>% predict(data.frame(time=time), type="lpmatrix")
    fit <- predictors %*% params

    # Map spline fit back to case counts
    cases <- fit %>% model$family$linkinv()
  
    # Calculate cumulative case counts to determine when we run out of treatment
    cumCases <- cumsum(cases) / sampleFreq
    treatmentAvail <- cumCases < treatmentMax

    # Calculate serious disease case counts
    cases[treatmentAvail] <- cases[treatmentAvail] * (1 - treatmentSuccessRate)
    cases <- cases * progressionRate
    return(cases)
  }
}
```

This is how we would use it:

```{r custom est parameterized, include=TRUE}
seriousEst <- model %>%
  outbreak.estimate.timeseries(
    modelTime, 
    seriousDiseaseCases(progressionRate=0.8, treatmentSuccessRate=0.9, treatmentMax=100, sampleFreq=sampleFreq), 
    samples=n, 
    level=0.95
  )
```

## Example 6: Scalar outcome measures

A scalar outcome measure is one that applies to the entire time period under investigation, rather than individual points in that time period. For example, consider the question: At which point in time have we seen 2.5% of all infection cases for that year? 

To answer questions like this one, we can use the `outbreak.estimate.scalars` function. Similar to `outbreak.estimate.timeseries`, it takes a model, a sampling time vector, an outcome calculation function, the number of samples to draw, and the confidence interval. Also similar to `outbreak.estimate.timeseries`, it returns median and lower/upper confidence limits for the outcome measure of interest. 

For this particular outcome measure, we can use the `outbreak.calc.thresholds` function to estimate the time when our infection disease crosses the 2.5% threshold of cumulative cases:

```{r estimate onset, include=TRUE}
seasonThreshold=0.025
onsetEst <- model %>% 
  outbreak.estimate.scalars(modelTime, outbreak.calc.thresholds(onset=seasonThreshold))

kable(onsetEst, caption="Estimated season onset", col.names=c("Lower CL", "Median", "Upper CL"))
```

## Example 7: Accessing individual scalar samples

Similar to time series outcomes, we can obtain the individual samples of a scalar outcome --- which can be useful for visualization --- using the `outbreak.estimate.scalars.sample` function:

```{r plot onset distribution, include=TRUE}
onsetSamples <- model %>% 
  outbreak.estimate.scalars.sample(modelTime, outbreak.calc.thresholds(onset=seasonThreshold), samples=n)

basePlot(cumCasesEst) +
  geom_ribbon(aes(x=time, ymin=lower, ymax=upper), fill=grey(.75)) +
  geom_segment(aes(x=-Inf, xend=Inf, y=seasonThreshold, yend=seasonThreshold), linetype="13") +
  geom_point(data=obs, aes(x=time, y=cases.cum.frac)) +
  geom_violinh(
    data=onsetSamples,
    aes(x=onset, y=seasonThreshold),
    width=.1,
    fill="gray50", color="black",
    trim=FALSE, draw_quantiles=c(0.025, 0.5, 0.975)
  ) +
  labs(x=NULL, y="Relative cumulative incidence")
```

## Example 8: Estimation of a custom time series outcome

Suppose this infectious disease can be mitigated by use of prophylaxis, but the prophylaxis — due to its cost — is only recommended for high-risk patients during peaks of disease activity. As a result, a potentially interesting outcome measure is the fraction of cases that occur while prophylaxis is active (“preventable fraction”). Let’s consider prophylaxis that provides 100% protection from infection starting in week 20 and lasting 24 weeks, and estimate its preventable fraction.

As with time series outcomes, we write a function that takes the GAM model, the parameter matrix, and the sampling time vector, and we return our outcome measure in a one-row data frame. (We can calculate multiple outcome measures, returning each in its own column of the data frame, although this is not shown here.)

As before, we can use function-in-function approach to allow the parameters of our custom outcome measure to be easily adjusted:

```{r custom outcome function, include=TRUE}
preventableFraction <- function(ppxStart, ppxDuration) {
    ppxEnd <- ppxStart + ppxDuration
    function(model, params, time) {
      # Calculate estimate cases
      predictors <- predict(model, data.frame(time=time), type="lpmatrix")
      cases <- model$family$linkinv(predictors %*% params)

      # Calculate preventable cases (occuring which prophylaxis is active)
      cases <- data.frame(time=time, cases=cases)
      totalCases <- sum(cases$cases)
      preventableCases <- sum(cases$cases[cases$time >= ppxStart & cases$time <= ppxEnd])

      # Calculate and return preventable fraction
      data.frame(preventable=c(preventableCases / totalCases))
    }
}
```

Then we call the package to get an interval estimate of our custom outcome measure:

```{r custom outcome estimate, include=TRUE}
preventableEst <- outbreak.estimate.scalars(
  model, 
  modelTime, 
  preventableFraction(ppxStart=20, ppxDuration=24)
)

kable(preventableEst, caption="Estimated preventable fraction", col.names=c("Lower CL", "Median", "Upper CL"))
```

## Example 9: Accessing samples of a custom outcome measure

Direct access to samples from `outbreak.estimate.scalars.sample` can, of course, be combined with custom scalar outcome calculation, which — among other things — makes it easy to plot the distribution of a custom scalar outcome:

```{r custom outcome distribution, include=TRUE, fig.width=6, fig.height=2}
preventableSamples <- outbreak.estimate.scalars.sample(model, modelTime, preventableFraction(ppxStart=20, ppxDuration=24), samples=n)

ggplot(preventableSamples) +
  theme_light() +
  scale_y_continuous() +
  scale_x_continuous() + 
  labs(x="Preventable fraction", y=NULL) + 
  coord_cartesian(xlim=range(c(0, 1))) +
  theme(
    panel.grid.major.y=element_blank(),
    legend.title=element_blank(),
    axis.ticks.y=element_blank(),
    axis.text.y=element_blank(),
    legend.position="bottom"
  ) +
  geom_violinh(
    aes(y=0, x=preventable),
    width=.1,
    fill="gray50", color="black",
    trim=FALSE, draw_quantiles=c(0.025, 0.5, 0.975)
  )
```

