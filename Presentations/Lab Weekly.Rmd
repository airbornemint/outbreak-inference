---
title: "Splines. Also, RSV"
output:
  ioslides_presentation: default
  html_document:
    mathjax: default
  beamer_presentation: default
  slidy_presentation: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

# Foreshadowing

 * What are splines anyway?
 * What good are splines for modeling?
 * What did I learn about RSV?

# Splines

## Splines: A brief history

## Splines: Math

A *spline* is a *piecewise polynomial* function on $[a, b] \subset \mathbb{R}$. The points $t_0, t_1, \dots, t_n$ at which the polynomial *segments are joined* are called *knots*.

$$
S(x) = \begin{cases}
P_0(x): t \in [t_0, t_1) \\
P_1(x): t \in [t_1, t_2) \\
\cdots \\
P_{n-1}(x): t \in [t_{n-1}, t_n]
\end{cases}
$$

If $P_i$ are *polynomials of degree â‰¤ m*, then the *spline* S has *degree m* and order m+1.

A spline is *continuous in all derivatives* everywhere *except* at its *knots*. At its knots a spline can have *continuity order* ranging from -1 (*no continuity*) through m-1.

```{r, echo=FALSE, warning=FALSE, message=FALSE}
import::from(plotly, plot_ly, add_lines, add_markers, TeX, config)
import::from(magrittr, `%>%`, `%<>%`)

# Plot piecewise continuous function over range. Range is a vector containing points of discontinuity; for example range = c(1, 2, 3) means range is (1, 3) with a discontinuity at 2. 
add_func = function(plot, range, dx, f, color=NA, ...) {
  # x must include points of discontinuity because they have to have y=NA
  x = seq(min(range), max(range), by=dx)
  x = sort(unique(c(x, range)))

  y = f(x)
  y[x %in% range] = NA
  
  plot %<>% add_lines(x=x, y=y, line=list(color=color), ...)
}
```

## Spline \#1: degree = 1, continuity = 0

```{r}
f1 = function(x) ifelse(x < 1, x, -x/2 + 1.5)
f2 = function(x) ifelse(x < 1, 1, -1/2)

plot_ly() %>% 
  add_func(c(0, 1, 2), 0.001, f1, 1, name=TeX("y")) %>%
  add_func(c(0, 1, 2), 0.001, f2, 2, name=TeX("dy/dx")) %>%
  config(mathjax="cdn")
```

## Spline \#2: degree = 1, continuity = -1

```{r}
f1 = function(x) ifelse(x < 1, x, -x/2 + 1)
f2 = function(x) ifelse(x < 1, 1, -1/2)

plot_ly() %>% 
  add_func(c(0, 1, 2), 0.001, f1, name=TeX("y")) %>%
  # add_func(c(0, 1, 2), 0.001, f2, name=TeX("dy/dx")) %>%
  config(mathjax="cdn")
```

## Spline \#3: degree = 2, continuity = -1

```{r}
f1 = function(x) ifelse(x < 1, x**2, (x-1)**2+2)

plot_ly() %>% 
  add_func(c(0, 1, 2), 0.001, f1, name=TeX("y")) %>%
  config(mathjax="cdn")
```

## Spline \#4: degree = 2, continuity = 0

```{r}
f1 = function(x) ifelse(x < 1, x**2, (x-1)**2+1)
f2 = function(x) ifelse(x < 1, 2*x, 2*(x-1))

plot_ly() %>% 
  add_func(c(0, 1, 2), 0.001, f1, name=TeX("y")) %>%
  add_func(c(0, 1, 2), 0.001, f2, name=TeX("dy/dx")) %>%
  config(mathjax="cdn")
```

## Spline \#5: degree = 2, continuity = 1

```{r}
f1 = function(x) ifelse(x < 1, x**2, -(x-2)**2+2)
f2 = function(x) ifelse(x < 1, 2*x, -2*(x-2))
f3 = function(x) ifelse(x < 1, 2, -2)

plot_ly() %>% 
  add_func(c(0, 1, 2), 0.001, f1, name=TeX("y")) %>%
  add_func(c(0, 1, 2), 0.001, f2, name=TeX("dy/dx")) %>%
  add_func(c(0, 1, 2), 0.001, f3, name=TeX("d^2y/dx^2")) %>%
  config(mathjax="cdn")
```

## Basis splines: Math

Splines *most common in practical use* are those with degree m and *continuity order m-1*. 

For a *given knot vector* $\vec{t} = (t_0, \dots t_n)$, and a *given spline degree* m, there exists a *unique set* of splines (*basis splines*) meeting the following criteria:

 * *Locality*: Basis spline $B_i$ is zero outside of the segment $[t_i, t_{i+n}]$
 * *Scaling*: $\sum B_i(x) = 1, \forall x \in [t_m, t_{n-m}]$
 
```{r}
bspline = function(knots, degree, idx) {
  if (degree == 0) {
    return(function(x) as.numeric(x >= knots[idx] & x < knots[idx + 1 + degree]))
  } else {
    return(function(x) {
      (x - knots[idx]) / (knots[idx + degree] - knots[idx]) * bspline(knots, degree - 1, idx)(x) + 
        (knots[idx + degree + 1] - x) / (knots[idx + degree + 1] - knots[idx + 1]) * bspline(knots, degree-1, idx+1)(x)
    })
  } 
}
  
add_bspline = function(plot, knots, degree, idx, dx, ...) {
  plot %>% add_func(c(knots[idx], knots[idx + 1 + degree] - dx), dx, bspline(knots, degree, idx), name=TeX(sprintf("B_{%d,%d}", degree, idx)), ...)
}

add_bsplines = function(plot, knots, degree, dx, colors=NA, ...) {
  for (idx in 1:(length(knots) - 1 - degree)) {
    plot %<>% add_bspline(knots, degree, idx, dx, color=colors[idx], ...)
  }
  
  return(plot)
}
```

## Basis splines \#1: degree = 1

```{r}
k = 0:10

plot_ly() %>% 
  add_bsplines(k, 1, 0.001) %>%
  config(mathjax="cdn")

```

## Basis splines \#2: degree = 2

```{r}
k = 0:10

plot_ly() %>% 
  add_bsplines(k, 2, 0.001) %>%
  config(mathjax="cdn")

```

## Basis splines: Importance

*All splines* of degree m and continuity order m-1 over the knot vector $\vec t$ can be expressed as a *linear combination of basis splines*.

Think of basis splines as *blending* functions that provide *smooth transitions* between fixed *control points*.

*Control points shape the spline.*

```{r}
spline_interpolate = function(knots, controls, degree) {
  function(x) {
    colSums(
      plyr::aaply(
        1:(length(knots) - 1 - degree), 1, 
        function(idx) { controls[idx] * bspline(knots, degree, idx)(x) }
      )
    )
  }
}

spline_color = function(knots, controls, degree) {
  controls = col2rgb(controls)
  function(x) {
    r = raster::clamp(colSums(
      plyr::aaply(
        1:(length(knots) - 1 - degree), 1, 
        function(idx) { controls["red", idx] * bspline(knots, degree, idx)(x) }
      )
    ) / 255, 0, 1)
    g = raster::clamp(colSums(
      plyr::aaply(
        1:(length(knots) - 1 - degree), 1, 
        function(idx) { controls["green", idx] * bspline(knots, degree, idx)(x) }
      )
    ) / 255, 0, 1)
    b = raster::clamp(colSums(
      plyr::aaply(
        1:(length(knots) - 1 - degree), 1, 
        function(idx) { controls["blue", idx] * bspline(knots, degree, idx)(x) }
      )
    ) / 255, 0, 1)
    
    rgb(r, g, b)
  }
}

add_blend_color = function(plot, knots, controls, degree, dx, y0=1.1) {
  x = (knots[1:(length(knots) - degree - 1)] + knots[(2 + degree):length(knots)]) / 2
  y = rep(y0, length(controls))
  plot %<>% add_markers(x=x, y=y, marker=list(color=controls, size=20))

  xmin = knots[1 + degree]
  xmax = knots[length(knots) - degree]
  x = seq(xmin, xmax, by=dx)
  y = rep(y0, length(x))
  color = spline_color(knots, controls, degree)(x)
  plot %<>% add_markers(x=x, y=y, marker=list(color=color), showlegend=FALSE)
  
  return(plot)
}

add_blend_y = function(plot, knots, controls, degree, dx) {
  xmin = knots[1 + degree]
  xmax = knots[length(knots) - degree]
  x = seq(xmin, xmax, by=dx)
  y = spline_interpolate(knots, controls, degree)(x)
  plot %<>% add_markers(x=x, y=y, showlegend=FALSE)

  x = (knots[1:(length(knots) - degree - 1)] + knots[(2 + degree):length(knots)]) / 2
  y = controls
  plot %<>% add_markers(x=x, y=y, marker=list(color="black"))
  
  return(plot)
}
```

## Blending \#1: Color (degree = 1)

```{r}
k = 0:10
controls = c(hsv(0), hsv(0.1), hsv(0.1), hsv(0.2), hsv(0.75), hsv(0.8), hsv(1), rgb(0, 0, 0), hsv(1))

plot_ly() %>% 
  add_bsplines(k, 1, 0.01, colors=controls, showlegend=FALSE) %>%
  add_blend_color(k, controls, 1, 0.01) %>%
  config(mathjax="cdn")
```

## Blending \#2: Position (degree = 1)

```{r}
k = 0:10
controls = c(1.5, 1.6, 1.6, 1.7, 1.75, 1.8, 2, 1.5, 2)

plot_ly() %>% 
  add_bsplines(k, 1, 0.01, colors=controls, showlegend=FALSE) %>%
  add_blend_y(k, controls, 1, 0.01) %>%
  config(mathjax="cdn")
```

## Blending \#3: Position (degree = 2)

```{r}
k = 0:10
controls = c(1.5, 1.6, 1.6, 1.7, 1.75, 1.8, 2, 1.5)

plot_ly() %>% 
  add_bsplines(k, 2, 0.01, colors=controls, showlegend=FALSE) %>%
  add_blend_y(k, controls, 2, 0.01) %>%
  config(mathjax="cdn")
```

# Basis spline modeling

## B-Spline Modeling: The Basics

*Control points shape the spline*. In a spline model, *model parameters* are (related to) *control points*.

In a simple B-spline model, *quality of fit* is measured by *mean square error* (MSE).

```{r}
import::from(mgcv, gam)
import::from(plotly, add_segments)
add_psplines = function (plot, x, y, k, m.fit, m.penalty, cyclic=FALSE, show.splines=TRUE, show.knots=show.splines, deriv=0) {
  data = data.frame(x=x, y=y)
  if (cyclic) {
    model = gam(y ~ s(x, k=k, bs="cp", m=c(m.fit, m.penalty)), family=gaussian, data=data)
  } else {
    model = gam(y ~ s(x, k=k, bs="ps", m=c(m.fit, m.penalty)), family=gaussian, data=data)
  }
  yhat = predict(model, data.frame(x=x))
  # p = predict(model, data.frame(x=x), type="lpmatrix")
  plot %<>% 
    add_markers(x=x, y=y, name="observed") %>%
    add_lines(x=x, y=yhat, name="model")

  knots = model$smooth[[1]]$knots
  innerKnots = knots[(m.fit+2):(k+1)]
  if (show.splines) {  
    for (idx in 1:k) {
      xMin = max(knots[idx], min(innerKnots))
      xMax = min(knots[idx+m.fit+2], max(innerKnots))
      x = seq(xMin, xMax, by=0.01)
      
      pred = mgcv:::Predict.matrix3(model$smooth[[1]], data.frame(x=x))$X
      plot %<>% add_lines(x=x, y=pred[,idx], showlegend=FALSE)
    }
  }
  
  if (show.knots) {
    if (cyclic) {
      knotsToShow = knots
    } else {
      knotsToShow = innerKnots
    }
    for (k in knotsToShow) {
      plot %<>% add_segments(x=k, xend=k, y=-1, yend=+1, line=list(color="black"), showlegend=FALSE)
    }
  }
  
  while (deriv > 0) {
    yhat = diff(yhat) / diff(x)
    x = (x[1:(length(x) - 1)] + x[2:length(x)]) / 2
    plot %<>% add_lines(x=x, y=yhat, name="model")
    deriv = deriv - 1
  }
  
  plot
}
```

## B-Spline Model #1

```{r}
set.seed(0)
f = function(x) (1 - (2 * x - 1/2)**2)/2
x = seq(0, 1, by=0.01)
y = rnorm(length(x), mean=f(x), sd=0.025)

plot_ly() %>% 
  add_psplines(x, y, 3, 0, 0)

```

## B-Spline Model #2

```{r}
set.seed(0)
f = function(x) (1 - (2 * x - 1/2)**2)/2
x = seq(0, 1, by=0.01)
y = rnorm(length(x), mean=f(x), sd=0.025)

plot_ly() %>% 
  add_psplines(x, y, 10, 0, 0)

```

## B-Spline Model #2

```{r}
set.seed(0)
f = function(x) (1 - (2 * x - 1/2)**2)/2
x = seq(0, 1, by=0.01)
y = rnorm(length(x), mean=f(x), sd=0.025)

plot_ly() %>% 
  add_psplines(x, y, 20, 0, 0)

```

## B-spline Overfitting: Penalties

B-spline fitting with MSE is *sensitive to number of knots*. Too *many knots* lead to *overfitting*.

One solution to this problem is to include *smoothness* in *measure of fit*; this is known as *"penalty"*.

Most common penalty is *integral of second derivative squared*, also knows as 2nd order penalty.

*B-splines* used for fitting *with a penalty* term are known as penalized B-splines, or *P-splines*.

## B-Spline Model #3

```{r}
set.seed(0)
f = function(x) (1 - (2 * x - 1/2)**2)/2
x = seq(0, 1, by=0.01)
y = rnorm(length(x), mean=f(x), sd=0.025)

plot_ly() %>% 
  add_psplines(x, y, 20, 0, 2)

```

## B-Spline Modeling: Cyclic Time

B-splines make *no smoothness guarantee* at the beginning and end of a *cyclic time* period.

```{r}
set.seed(0)
f = function(x) cos(x * 2 * pi)
x = seq(0, 1, by=0.001)
y = rnorm(length(x), mean=f(x), sd=0.025)

plot_ly() %>% 
  add_psplines(x, y, 500, 0, 2, show.splines=FALSE, deriv=1)

```

## B-Spline Modeling: Cyclic Time

That is what *cyclic B-splines* are used for.

```{r}
set.seed(0)
f = function(x) cos(x * 2 * pi)
x = seq(0, 1, by=0.001)
y = rnorm(length(x), mean=f(x), sd=0.025)

plot_ly() %>% 
  add_psplines(x, y, 500, 0, 2, cyclic=TRUE, show.splines=FALSE, deriv=1)

```

## B-spline Modeling: Higher Orders

*Cubic spline* with *2nd order penalty* is a reasonable place to start and gives an excellent tradeoff of *smoothness* and *computational efficiency*

```{r}
set.seed(0)
f = function(x) sin(2*pi*x)
x = seq(0, 1, by=0.01)
y = rnorm(length(x), mean=f(x), sd=0.025)
y2 = f(x)

plot_ly() %>% 
  add_psplines(x, y, 4, 2, 2, cyclic=TRUE, show.splines=FALSE, show.knots=TRUE)
```

